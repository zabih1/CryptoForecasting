import requests
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import MinMaxScaler


def fetch_historical_data(symbol, interval='1d', start_date=None, end_date=None, limit=1000):
    url = f'https://api.binance.com/api/v3/klines?symbol={symbol}&interval={interval}&limit={limit}'
    
    if start_date:
        url += f'&startTime={int(pd.Timestamp(start_date).timestamp() * 1000)}'
    if end_date:
        url += f'&endTime={int(pd.Timestamp(end_date).timestamp() * 1000)}'
    
    response = requests.get(url)
    
    if response.status_code != 200:
        raise Exception(f'Error fetching data: {response.status_code} - {response.text}')
    
    data = response.json()
    
    df = pd.DataFrame(data, columns=[
        'timestamp', 'open', 'high', 'low', 'close', 'volume',
        'close_time', 'quote_asset_volume', 'number_of_trades',
        'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'ignore'
    ])
    
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)
    df.drop(columns=['close_time', 'ignore'], inplace=True)
    
    # Convert columns to numeric
    df = df.apply(pd.to_numeric, errors='coerce')
    
    df['price_range'] = df['high'] - df['low']
    df['close_to_open'] = df['close'] - df['open']
    
    return df

# Example of fetching data
# symbol = 'BTCUSDT'  # Example: Bitcoin to USD
symbol = 'ETHUSDT'  
df = fetch_historical_data(symbol, start_date='2022-06-01', end_date='2025-02-06')
df.head()



# Preprocessing: Shift the target (closing price) by -1 to predict the next day's closing price
df['target'] = df['close'].shift(-1)

# Drop the last row because it will have a NaN target (due to the shift)
df = df.dropna()

features = ['open', 'high', 'low', 'volume', 'quote_asset_volume',
       'number_of_trades', 'taker_buy_base_asset_volume',
       'taker_buy_quote_asset_volume', 'price_range', 'close_to_open']




X = df[features]
y = df['target']  # Target variable: next day's closing price



# Split the data into training and testing sets
split_index = int(0.8 * len(X))
X_train, X_test = X[:split_index], X[split_index:]
y_train, y_test = y[:split_index], y[split_index:]



from sklearn.preprocessing import MinMaxScaler

# Apply Min-Max scaling to the features
scaler = MinMaxScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Display scaled features
pd.DataFrame(X_train_scaled, columns=X.columns).head()



# Train Linear Regression model
model = LinearRegression()
model.fit(X_train_scaled, y_train)


from sklearn.metrics import mean_absolute_error, root_mean_squared_error
import numpy as np
y_pred = model.predict(X_test_scaled)

mse = mean_squared_error(y_test, y_pred)
mae = mean_absolute_error(y_test, y_pred)
root_mean_squared_error = np.sqrt(mse)
print(f'Root Mean Squared Error: {root_mean_squared_error}')
print(f'Mean Absolute Error: {mae}')
print(f'Mean Squared Error: {mse}')


predictions = pd.DataFrame({'Actual': y_test, 'Predicted': y_pred})
predictions.tail()
